#!/bin/bash

# --- Global Variables (will be populated from parameters.ini) ---
VM_BACKUP_LIST=""
VM_BACKUP_PRI_ONLY=""
CREATE_BU_IMAGE=""
SNAPSHOTS=""
RETENTION_DAYS=""
VM_MOUNTPOINT=""
LIBVERT_LOCATION=""
VM_BACKUP_LOCATION=""
VM_BACKUP_LOCATION_USED_PCT=""
SHARES_CONFIG_DIR=""
LOG_FILE=""

# --- Read Input File Function ---
# Reads configuration parameters from an INI file located in the script's directory.
#
# @return {integer} 0 for success, 1 for failure.
read_input_file() {
    # Determine the script's directory to find the INI file.
    local script_dir
    script_dir=$(dirname "$(readlink -f "$0")")
    local ini_file="${script_dir}/parameters.ini"

    if [ ! -r "${ini_file}" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - FATAL: Configuration file not found or not readable at '${ini_file}'." >&2
        return 1
    fi

    # Read the INI file line by line.
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "${key}" =~ ^\s*# ]] && continue
        [[ -z "${key}" ]] && continue

        # Trim leading/trailing whitespace and quotes from key and value
        local trimmed_key
        trimmed_key=$(echo "${key}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        local trimmed_value
        trimmed_value=$(echo "${value}" | sed -e 's/^[[:space:]"]*//' -e 's/[[:space:]"]*$//')

        # Assign value to the corresponding global variable
        case "${trimmed_key}" in
            VM_BACKUP_LIST) VM_BACKUP_LIST="${trimmed_value}" ;;
            VM_BACKUP_PRI_ONLY) VM_BACKUP_PRI_ONLY="${trimmed_value}" ;;
            CREATE_BU_IMAGE) CREATE_BU_IMAGE="${trimmed_value}" ;;
            SNAPSHOTS) SNAPSHOTS="${trimmed_value}" ;;
            RETENTION_DAYS) RETENTION_DAYS="${trimmed_value}" ;;
            VM_MOUNTPOINT) VM_MOUNTPOINT="${trimmed_value}" ;;
            LIBVERT_LOCATION) LIBVERT_LOCATION="${trimmed_value}" ;;
            VM_BACKUP_LOCATION) VM_BACKUP_LOCATION="${trimmed_value}" ;;
            VM_BACKUP_LOCATION_USED_PCT) VM_BACKUP_LOCATION_USED_PCT="${trimmed_value}" ;;
            SHARES_CONFIG_DIR) SHARES_CONFIG_DIR="${trimmed_value}" ;;
        esac
    done < "${ini_file}"

    return 0
}


# --- File Rotation Function ---
# Rotates files in a specified directory based on a pattern, keeping a maximum number.
#
# @param {string} dir - The directory containing the files.
# @param {string} pattern - The file pattern to match (e.g., "*.log", "libvirt-backup-*.tar.gz").
# @param {integer} max_files - The maximum number of files to keep.
# @return {integer} 0 for success.
file_rotation() {
    local dir="$1"
    local pattern="$2"
    local max_files="$3"

    log_message "INFO: Performing file rotation for pattern '${pattern}' in directory '${dir}'. Max files to keep: ${max_files}."
    
    # Use find to safely count files matching the pattern.
    local current_file_count
    current_file_count=$(find "${dir}" -maxdepth 1 -type f -name "${pattern}" | wc -l)

    if (( current_file_count > max_files )); then
        local num_to_delete=$((current_file_count - max_files))
        log_message "INFO: Found ${current_file_count} files, which exceeds the max of ${max_files}. Deleting the ${num_to_delete} oldest file(s)."
        
        # List files by modification time (oldest first), select the ones to delete, and remove them.
        find "${dir}" -maxdepth 1 -type f -name "${pattern}" -printf '%T@ %p\n' | sort -n | head -n "${num_to_delete}" | cut -d' ' -f2- | while read -r old_file; do
            log_message "INFO: Deleting old file: '${old_file}'"
            if ! rm -f "${old_file}"; then
                log_message "WARNING: Failed to delete old file '${old_file}'."
            fi
        done
    else
        log_message "INFO: ${current_file_count} file(s) found. No rotation needed for pattern '${pattern}'."
    fi
    return 0
}

# --- Logging Setup Function ---
# Initializes the logging environment, creates the log directory, and sets the
# log file for the current run.
#
# @uses global VM_BACKUP_LOCATION
# @uses global SNAPSHOTS
# @uses global LOG_FILE
# @return {integer} 0 for success, 1 for failure.
setup_logging() {
    local log_dir="${VM_BACKUP_LOCATION}/logs"

    # First, ensure the base backup location is accessible.
    if [ ! -d "${VM_BACKUP_LOCATION}" ] || [ ! -w "${VM_BACKUP_LOCATION}" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - FATAL: Base backup location '${VM_BACKUP_LOCATION}' does not exist or is not writable. Cannot setup logging." >&2
        return 1
    fi

    # Create the log directory if it doesn't exist.
    if ! mkdir -p "${log_dir}"; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - FATAL: Failed to create log directory '${log_dir}'." >&2
        return 1
    fi

    # Verify the log directory is writable.
    if [ ! -w "${log_dir}" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - FATAL: Log directory '${log_dir}' is not writable." >&2
        return 1
    fi

    # Set the global LOG_FILE variable for this script execution.
    LOG_FILE="${log_dir}/backup-$(date '+%Y-%m-%d_%H%M%S').log"
    
    # Create the log file immediately and check for success.
    if ! touch "${LOG_FILE}"; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - FATAL: Could not create log file at '${LOG_FILE}'." >&2
        LOG_FILE=""
        return 1
    fi

    # Call the dedicated file rotation function for the logs.
    local max_logs=$((SNAPSHOTS * 2))
    file_rotation "${log_dir}" "backup-*.log" "${max_logs}"

    return 0
}

# --- Logging Function ---
# A simple function to log messages to a specified file and to the console.
# Relies on the global LOG_FILE variable being set by setup_logging().
#
# @param {string} Message - The message to be logged.
log_message() {
    local message="$1"
    # Fallback to stderr if logging has not been initialized.
    if [[ -z "${LOG_FILE}" ]]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - UNINITIALIZED_LOG - ${message}" >&2
        return
    fi
    # Logs the message with a timestamp to both the console and the log file.
    echo "$(date '+%Y-%m-%d %H:%M:%S') - ${message}" | tee -a "${LOG_FILE}"
}

# --- Parameters Validation Function ---
# Validates that the core global variables are set and look reasonable.
#
# @return {integer} 0 for success, 1 for failure.
validate_parameters() {
    log_message "INFO: Validating configuration parameters..."
    local has_error=0

    if ! [[ "${SNAPSHOTS}" =~ ^[1-9][0-9]*$ ]]; then
        log_message "ERROR: SNAPSHOTS must be a non-zero integer. Current value: '${SNAPSHOTS}'"
        has_error=1
    fi
    if ! [[ "${VM_BACKUP_LOCATION_USED_PCT}" =~ ^[0-9]+$ ]] || [ "${VM_BACKUP_LOCATION_USED_PCT}" -gt 100 ]; then
        log_message "ERROR: VM_BACKUP_LOCATION_USED_PCT must be an integer between 0-100. Current value: '${VM_BACKUP_LOCATION_USED_PCT}'"
        has_error=1
    fi
    if [ ! -d "${VM_MOUNTPOINT}" ]; then
        log_message "ERROR: VM_MOUNTPOINT directory does not exist: '${VM_MOUNTPOINT}'"
        has_error=1
    fi
    if [ ! -d "${LIBVERT_LOCATION}" ]; then
        log_message "ERROR: LIBVERT_LOCATION directory does not exist: '${LIBVERT_LOCATION}'"
        has_error=1
    fi
    if [ ! -d "${VM_BACKUP_LOCATION}" ]; then
        log_message "ERROR: VM_BACKUP_LOCATION directory does not exist: '${VM_BACKUP_LOCATION}'"
        has_error=1
    fi

    if [ ${has_error} -ne 0 ]; then
        return 1
    fi

    log_message "INFO: Configuration parameters appear valid."
    return 0
}

# --- Mount Check Function ---
# Checks if a given mount point is valid and has the correct filesystem type (btrfs or xfs).
#
# @uses global VM_MOUNTPOINT
# @return {integer} 0 for success, 1 for failure.
mount_check() {
    log_message "INFO: Starting check for mount point: '${VM_MOUNTPOINT}'"

    if ! mountpoint -q "${VM_MOUNTPOINT}"; then
        log_message "ERROR: Path '${VM_MOUNTPOINT}' is not a valid mount point or does not exist."
        return 1
    fi
    log_message "INFO: Mount point '${VM_MOUNTPOINT}' exists and is valid."

    local fs_type
    fs_type=$(findmnt -no FSTYPE "${VM_MOUNTPOINT}")
    if [[ -z "${fs_type}" ]]; then
        log_message "ERROR: Could not determine filesystem type for '${VM_MOUNTPOINT}'."
        return 1
    fi
    log_message "INFO: Detected filesystem type is '${fs_type}'."

    if [[ "${fs_type}" == "btrfs" || "${fs_type}" == "xfs" ]]; then
        log_message "SUCCESS: Filesystem type '${fs_type}' is acceptable."
        return 0
    else
        log_message "ERROR: Filesystem type for '${VM_MOUNTPOINT}' is '${fs_type}'. It must be 'btrfs' or 'xfs'."
        return 1
    fi
}

# --- Libvirt Backup Function ---
# Backs up libvirt configuration files and manages snapshot rotation.
#
# @uses global LIBVERT_LOCATION, VM_BACKUP_LOCATION, SNAPSHOTS
# @return {integer} 0 for success, 1 for failure.
libvirt_backup() {
    log_message "INFO: Starting libvirt configuration backup..."

    if [ ! -r "${LIBVERT_LOCATION}" ]; then
        log_message "ERROR: Libvirt location '${LIBVERT_LOCATION}' is not readable."
        return 1
    fi
    log_message "INFO: Source directory '${LIBVERT_LOCATION}' is readable."

    local backup_subdir="${VM_BACKUP_LOCATION}/libvirt"
    if ! mkdir -p "${backup_subdir}"; then
        log_message "ERROR: Failed to create backup subdirectory '${backup_subdir}'."
        return 1
    fi
    log_message "INFO: Backup destination '${backup_subdir}' is ready."

    local timestamp
    timestamp=$(date '+%Y-%m-%d_%H%M%S')
    local filename="libvirt-backup-${timestamp}.tar.gz"
    local full_backup_path="${backup_subdir}/${filename}"

    log_message "INFO: Creating backup archive: '${full_backup_path}'"
    if ! tar -czf "${full_backup_path}" -C "${LIBVERT_LOCATION}" .; then
        log_message "ERROR: tar command failed to create backup for '${LIBVERT_LOCATION}'."
        rm -f "${full_backup_path}"
        return 1
    fi
    log_message "INFO: Successfully created backup archive."

    file_rotation "${backup_subdir}" "libvirt-backup-*.tar.gz" "${SNAPSHOTS}"
    
    log_message "SUCCESS: Libvirt backup completed successfully."
    return 0
}

# --- VM Snapshot Function ---
# Creates copy-on-write (reflink) snapshots of VM disk images and rotates them.
#
# @uses global VM_MOUNTPOINT, SNAPSHOTS
# @return {integer} 0 for success, 1 for failure.
vm_snapshot() {
    log_message "INFO: Starting VM disk snapshot process..."
    local domains_dir="${VM_MOUNTPOINT}/domains"

    if [ ! -d "${domains_dir}" ]; then
        log_message "ERROR: VM domains directory '${domains_dir}' does not exist."
        return 1
    fi

    find "${domains_dir}" -mindepth 1 -maxdepth 1 -type d | while read -r vm_dir; do
        local vm_name
        vm_name=$(basename "${vm_dir}")
        log_message "INFO: Processing VM: ${vm_name}"

        find "${vm_dir}" -maxdepth 1 -type f -name "*.img" | while read -r disk_image; do
            local disk_basename
            disk_basename=$(basename "${disk_image}")
            log_message "INFO: Processing disk: ${disk_basename}"

            local timestamp
            timestamp=$(date '+%Y%m%d%H%M%S')
            local snapshot_file="${disk_image}_snapshot_${timestamp}.fullsnap"
            
            log_message "INFO: Creating reflink snapshot for '${disk_image}' -> '${snapshot_file}'"
            if ! cp -p --reflink=always "${disk_image}" "${snapshot_file}"; then
                log_message "ERROR: Failed to create snapshot for '${disk_image}'."
            else
                log_message "INFO: Successfully created snapshot '${snapshot_file}'."
            fi

            local rotation_pattern="${disk_basename}_snapshot_*.fullsnap"
            file_rotation "${vm_dir}" "${rotation_pattern}" "${SNAPSHOTS}"
        done
    done

    log_message "SUCCESS: VM disk snapshot process completed."
    return 0
}


# --- Main Execution ---

# Step 1: Read configuration from INI file. This must happen before logging is set up.
if ! read_input_file; then
    exit 1
fi

# Step 2: Initialize logging. This must happen after reading the config.
if ! setup_logging; then
    echo "CRITICAL: Logging setup failed. Aborting script." >&2
    exit 1
fi

# Step 3: Validate all parameters read from the file.
if ! validate_parameters; then
    log_message "ERROR: Configuration validation failed. Aborting script."
    exit 1
fi

# --- Begin Backup Logic ---
log_message "--- Running Mount Point Check ---"
if ! mount_check; then
    log_message "ERROR: Mount point check failed. Halting script."
    exit 1 
fi
log_message "Mount point check passed successfully."


log_message "--- Running Libvirt Backup ---"
if ! libvirt_backup; then
    log_message "ERROR: Libvirt backup failed. Please review the log file."
fi
log_message "Libvirt backup completed successfully."


log_message "--- Running VM Snapshot ---"
if ! vm_snapshot; then
    log_message "ERROR: VM snapshot process failed. Please review the log file."
fi
log_message "VM snapshot process completed successfully."

